"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const index_1 = require("../utils/index");
function usePanClosestElement({ className, onPanStart, onPan, onPanEnd, }) {
    const canvases = react_1.useRef(document.getElementsByClassName(className));
    react_1.useLayoutEffect(() => {
        const isBrowser = typeof window !== "undefined";
        const isSupported = isBrowser && window && window.addEventListener;
        if (!isSupported)
            return;
        const dpi = window.devicePixelRatio || 1;
        let isPanning = false;
        let elementId = null;
        let bounds = null;
        if (canvases.current.length === 0) {
            canvases.current = document.getElementsByClassName(className);
        }
        function handleDown(event) {
            event.stopPropagation();
            const { clientX, clientY, target } = event;
            isPanning = true;
            if (target) {
                elementId = target.id;
                bounds = target.getBoundingClientRect();
                if (onPanStart && bounds && elementId) {
                    const { top, left, width, height } = bounds;
                    const { x, y } = index_1.getRelativeCoords(clientX, clientY, left, top, dpi);
                    onPanStart({ panX: x, panY: y, width, height, dpi, elementId });
                }
            }
        }
        function handleMove(event) {
            event.stopPropagation();
            if (elementId && isPanning && onPan && bounds) {
                const { clientX, clientY } = event;
                const { top, left, width, height } = bounds;
                const { x, y } = index_1.getRelativeCoords(clientX, clientY, left, top, dpi);
                onPan({ panX: x, panY: y, width, height, dpi, elementId });
            }
        }
        function handleUp(event) {
            event.stopPropagation();
            if (elementId && isPanning && onPanEnd && bounds) {
                const { clientX, clientY } = event;
                const { top, left, width, height } = bounds;
                const { x, y } = index_1.getRelativeCoords(clientX, clientY, left, top, dpi);
                onPanEnd({ panX: x, panY: y, width, height, dpi, elementId });
            }
            isPanning = false;
            elementId = null;
            bounds = null;
        }
        const canvasesLength = canvases.current.length;
        for (let i = 0; i < canvasesLength; i++) {
            canvases.current[i].addEventListener("pointerdown", handleDown);
        }
        window.addEventListener("pointermove", handleMove);
        window.addEventListener("pointerup", handleUp);
        return () => {
            for (let i = 0; i < canvasesLength; i++) {
                canvases.current[i].removeEventListener("pointerdown", handleDown);
            }
            window.removeEventListener("pointermove", handleMove);
            window.removeEventListener("pointerup", handleUp);
        };
    }, [className, onPanStart, onPan, onPanEnd]);
}
exports.default = usePanClosestElement;
