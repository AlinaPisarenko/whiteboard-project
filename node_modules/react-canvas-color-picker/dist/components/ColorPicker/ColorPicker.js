"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const Hue_1 = __importDefault(require("../Hue/Hue"));
const Spectrum_1 = __importDefault(require("../Spectrum/Spectrum"));
const Alpha_1 = __importDefault(require("../Alpha/Alpha"));
const usePanClosestElement_1 = __importDefault(require("../../hooks/usePanClosestElement"));
const index_1 = require("../../constants/index");
const index_2 = require("../../utils/index");
const ColorPicker_module_css_1 = __importDefault(require("./ColorPicker.module.css"));
const defaultFormats = ["rgba"];
const defaultColor = { r: 255, g: 255, b: 255, a: 1 };
const ColorPicker = React.forwardRef((props, ref) => {
    const { initialColor = defaultColor, spectrumWidth = 240, spectrumHeight = 240, sliderWidth = 240, sliderHeight = 14, spectrum = "hsva", formats = defaultFormats, className, spectrumClasses, hueClasses, alphaClasses, handleClasses, hideAlpha = false, onPanStart, onPan, onPanEnd, } = props;
    const [color, setColor] = React.useState(() => {
        return index_2.formatColorBySpectrum(initialColor, spectrum);
    });
    const isFirstRender = React.useRef(true);
    const colorRef = React.useRef(color);
    React.useEffect(() => {
        colorRef.current = color;
    });
    // Store spectrum in ref so changes don't cause handles to jump before new color is set
    const spectrumRef = React.useRef(spectrum);
    React.useEffect(() => {
        spectrumRef.current = spectrum;
    }, [spectrum]);
    const sendChanges = React.useCallback(() => {
        const colors = index_2.getColorFormats(colorRef.current, formats);
        if (onPan) {
            onPan({ colors, canvasId: "none" });
        }
        else if (onPanEnd) {
            onPanEnd({ colors, canvasId: "none" });
        }
        else if (onPanStart) {
            onPanStart({ colors, canvasId: "none" });
        }
    }, [onPan, onPanEnd, onPanStart, formats]);
    const sendChangesRef = React.useRef(sendChanges);
    React.useEffect(() => {
        sendChangesRef.current = sendChanges;
    }, [sendChanges]);
    const handlePanStart = React.useCallback((event) => {
        const newColor = index_2.getColorChanges(event, colorRef.current);
        setColor(newColor);
        if (onPanStart) {
            const colors = index_2.getColorFormats(newColor, formats);
            onPanStart({ colors, canvasId: event.elementId });
        }
    }, [onPanStart, formats]);
    const handlePan = React.useCallback((event) => {
        const newColor = index_2.getColorChanges(event, colorRef.current);
        setColor(newColor);
        if (onPan) {
            const colors = index_2.getColorFormats(newColor, formats);
            onPan({ colors, canvasId: event.elementId });
        }
    }, [onPan, formats]);
    const handlePanEnd = React.useCallback((event) => {
        const newColor = index_2.getColorChanges(event, colorRef.current);
        setColor(newColor);
        if (onPanEnd) {
            const colors = index_2.getColorFormats(newColor, formats);
            onPanEnd({ colors, canvasId: event.elementId });
        }
    }, [onPanEnd, formats]);
    usePanClosestElement_1.default({
        className: className || index_1.COLOR_PICKER_CLASSNAME,
        onPanStart: handlePanStart,
        onPan: handlePan,
        onPanEnd: handlePanEnd,
    });
    // When spectrum is updated, reset the local color
    React.useEffect(() => {
        setColor((state) => {
            if (typeof spectrum !== "undefined") {
                return index_2.formatColorBySpectrum(state, spectrum);
            }
            return state;
        });
    }, [spectrum]);
    // When the formats change, send the new colors in callback
    React.useEffect(() => {
        if (isFirstRender.current) {
            isFirstRender.current = false;
        }
        else {
            sendChangesRef.current();
        }
    }, [formats]);
    // Imperative handler to externally set the color after mount
    React.useImperativeHandle(ref, () => ({
        setColor: (col) => {
            setColor(index_2.formatColorBySpectrum(col, spectrum));
        },
    }));
    return (React.createElement("div", { className: `${ColorPicker_module_css_1.default.container} ${className}` },
        React.createElement(Spectrum_1.default, { spectrumFormat: spectrumRef.current, hue: color.h, saturation: color.s, lightness: color.l, value: color.v, width: spectrumWidth, height: spectrumHeight, className: spectrumClasses, handleClasses: handleClasses }),
        React.createElement(Hue_1.default, { hue: color.h, width: sliderWidth, height: sliderHeight, className: hueClasses, handleClasses: handleClasses }),
        !hideAlpha && (React.createElement(Alpha_1.default, { hue: color.h, saturation: color.s, lightness: color.l, value: color.v, alpha: color.a, width: sliderWidth, spectrum: spectrumRef.current, height: sliderHeight, className: alphaClasses, handleClasses: handleClasses }))));
});
exports.default = React.memo(ColorPicker);
